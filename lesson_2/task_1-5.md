## Task 1
> Какие типы паттернов проектирования существуют?

* порождающие
* структурные
* поведенческие
* архитектурные

***

## Task 2
> Как можно улучшить Singleton при помощи trait-ов?

Вынести в trait код, который реализует singleton и подключать данный trait в требуемом классе

~~~php
trait Singleton
{
    private static $instance;

    public static function getInstance()
    {
        if (is_null(self::$instance)) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    private function __construct()
    {
    }

    private function __wakeup()
    {
    }

    private function __clone()
    {
    }
}
~~~

***

## Task 3
> Как реализуется паттерн «Фабричный метод»? В чем его отличие от паттерна «Фабрика»?

«Фабричный метод» реализуется в том же классе, в котором и используется объект, который он создает.
Подклассы могут переопределять данный метод, для того что бы получить другой тип создаваемого объекта.
Как правило создается как абстактный в базовом классе и переопределяется в подклассах.
«Фабрика» это как правило обобщенное название для функций, методов и классов, которые создают другие классы.

Реализация паттерна «Фабричный метод»
~~~php
class Department {
    public abstract function createEmployee($id);

    public function fire($id) {
        $employee = $this->createEmployee($id);
        $employee->paySalary();
        $employee->dismiss();
    }
}

class ITDepartment extends Department {
    public function createEmployee($id) {
        return new Programmer($id);
    }
}
~~~

***

## Task 4
> Объясните назначение и применение магических методов __get, __set, __isset, __unset,
  __call и __callStatic . Когда, как и почему их стоит использовать (или нет)?

* `__get()` - вызывается когда происходит обращение к недоступным свойствам. 
Можно использовать для обращения к методам, которые возврашают какие то данные как к обычным свойствам, 
для обращения к динамически создаваемым свойствам или данным которые хранятся в массиве или вне текущего объекта.
* `__set()` - вызывается когда происходит присвоение данных недоступным свойствам. 
Можно использовать там же где и `__set()`
* `__isset()` - вызывается при использовании `isset()` или `empty()` на недоступных свойствах.
Можно использовать для проверки существования переменной или наличия данных в ней в ситуациях описанных в `__get()`
* `__unset()` - вызывается при использовании `unset()` на недоступных свойствах.
Можно использовать для удаление переменной в ситуациях описанных в `__get()`
* `__call()` - запускается при вызове недоступных методов.
Пока нет идей где можно использовать. 
* `__callStatic()` - запускается при вызове недоступных методов в статическом контексте.
Пока нет идей где можно использовать. 

Основной минус использования данных методов в том что они снижают читаемость кода, 
поэтому стоит применять только если это действительно необходимо и качественно документировать это.

Из плюсов, то может пригодится с помощью `__set()` запретить динамическое создание свойств в обекте,
если это может привести к ошибке

~~~php
  public __set($n, $a)
  {
    throw new Exception();
  }
~~~

***

## Task 5
> Описать несколько структур данных из стандартной библиотеки PHP (SPL). Привести
  примеры использования.

* **Двусвязный список**

Связный список – это базовая динамическая структура данных, состоящая из узлов, каждый из
которых содержит как данные, так и ссылки на следующий и (или) предыдущий узел. Их
преимущество перед массивом – структурная гибкость: последовательность элементов может не
совпадать с порядком расположения данных в памяти, а обход всегда явно задается внутренними
связями.
Списки бывают трех типов: одно-, дву- и XOR-связные.

В качестве примера можно привести стек `SplStack` или очередь `SplQueue`

Пример реализации очереди:
~~~php
$queue = new SplQueue ();
$queue->enqueue('one');
$queue->enqueue('two');
$queue->enqueue('three');
echo $queue->dequeue(); // one
echo $queue->dequeue(); // two
echo $queue->bottom(); // three
~~~

* **Куча**

Это реализация древовидной структуры, в которой любой узел должен быть больше
своих потомков или равен им. Для узлов применяется пользовательский метод сравнения,
являющийся единым для всей структуры.

В библиотеке SPL присутствует две реализации `SplHeap`(`SplMaxHeap` и `SplMinHeap`) и `SplPriorityQueue`

Пример реализации кучи с сортировкой по возрастанию:
~~~php
$heap = new SplMinHeap ();
$heap->insert('777');
$heap->insert('666');
$heap->insert('111');
echo $heap->extract(); // 111
echo PHP_EOL;
echo $heap->extract(); // 666
echo PHP_EOL;
echo $heap->extract(); // 777
~~~

* **SplFixedArray**

Структура представляет собой массив с фиксированным количеством элементов.
`SplFixedArray` хранит данные в непрерывном виде, доступные через индексы,
а обычные массивы реализованы в виде упорядоченных хэш-таблиц. Данный вид массива работает быстрее, чем обычные массивы.

Пример реализации:
~~~php
$a = new SplFixedArray(10000);
        $count = 100000;

	for($i = 0; $i<$count; $i++)
	{
		$a[$i] = $i;
		
		if ($i==9999) $a->setSize(100000);
	}
~~~

* **SplObjectStorage**

Данная структура представляет собой хранилище объектов.
Объекты можно прикреплять к хранилищу, удалять, получать текущий объект.

Пример реализации:
~~~php
$s = new SplObjectStorage();

$o1 = new StdClass;
$o2 = new StdClass;
$o3 = new StdClass;

$s->attach($o1); //
$s->attach($o2);

var_dump($s->contains($o1)); // bool(true)
var_dump($s->contains($o2)); // bool(true)
var_dump($s->contains($o3)); // bool(false)

$s->detach($o2); //

var_dump($s->contains($o1)); // bool(true)
var_dump($s->contains($o2)); // bool(false)
var_dump($s->contains($o3)); // bool(false)
~~~
***

## Task 6
> Найти все ошибки в коде:

~~~php
interface MyInt {
    public function funcI ();
    private function funcP (); // в интерфейте не может быть приватных методов
}
class A {
    protected prop1; // имя свойства должно начинаться с '$'
    private prop2;   // имя свойства должно начинаться с '$'
    function funcA (){
        return $this -> prop2;
    }
}
class B extends A {
    function funcB (){
        return $this -> prop1;
    }
}
class C extends B implements MyInt {
    function funcB (){
        return $this -> prop1;
    }
    private function funcP (){ // у метода не может быть переопределен модификатор доступа
        return 123;
    }
    // класс должен реализовывать все методы объявленные в интерфейсе, который он реализует
    //public function funcI()
    //{
    //}
}
$b = new B ();
$b -> funcA ();
$c = new C ();
$c -> funcI ();
~~~
***